-- EEBAX - Euphoria Event Based API for XML
-- Copyright (c) Thomas Parslow 2002
-- tom@almostobsolete.net
-- Lots of ideas pinched from SAX :)

-- --------------------------------------------------------------------------
--
-- License
--
-- The contents of this file are subject to the Jabber Open Source License
-- Version 1.0 (the "License").  You may not copy or use this file, in either
-- source code or executable form, except in compliance with the License.  You
-- may obtain a copy of the License at http://www.jabber.com/license/ or at
-- http://www.opensource.org/.  
--
-- Software distributed under the License is distributed on an "AS IS" basis,
-- WITHOUT WARRANTY OF ANY KIND, either express or implied.  See the License
-- for the specific language governing rights and limitations under the
-- License.
--
-- Copyrights
-- 
-- Copyright (c) Thomas Parslow 2002 unless otherwise stated
-- 
-- --------------------------------------------------------------------------

-- If you need to do something with this library that is prohibited by the License then contact me, I'm sure we can work it out :)

-- UNSPORTED RIGHT NOW:
-- VALIDATION
-- ENTITIES (APART FROM DEFAULT ENTITIES)
-- [INCLUDE[ and [IGNORE[ sections will cause weird stuff to happen

constant FULL_NAMESPACE_CHECKING = 0 --1 to enable checking for undeclared namespaces

-- BEGIN Includes

include get.e
include wildcard.e
include machine.e

-- END Includes

-- BEGIN Global Constants
-- Error codes
global constant EEBAX_ERROR_INVALID_CHARACTER_ENCODING = 1,
                EEBAX_ERROR_INVALID_WHITESPACE         = 2,
                EEBAX_ERROR_UNEXPECTED                 = 3,
                EEBAX_ERROR_INVALID_OUTSIDE_DTD        = 4,
                EEBAX_ERROR_INVALID_EXTERNAL_ID        = 5,
                EEBAX_ERROR_EXPECTED_STRING_LITERAL    = 6,
                EEBAX_ERROR_INVALID_NAME_CHAR          = 7,
                EEBAX_ERROR_EXPECTED_EQUAL             = 8,
                EEBAX_ERROR_UNDECLARED_NAMESPACE       = 9,
                EEBAX_ERROR_END_TAG_DOES_NOT_MATCH     = 10,
                EEBAX_ERROR_INVALID_IN_ELEMENT         = 11,
                EEBAX_ERROR_STARTDOCUMENT_NOT_CALLED   = 12,
                EEBAX_ERROR_DUPLICATE_ATT              = 13,
                EEBAX_ERROR_INVALID_IN_DTD             = 14
                
-- Atts structure constants
global constant EEBAX_ATTS_QNAME     = 1,
                EEBAX_ATTS_VALUE     = 2,
                EEBAX_ATTS_URI       = 3,
                EEBAX_ATTS_LOCALNAME = 4
-- END Global Constants 

-- BEGIN Local Constants
-- Error descriptions match up with error codes above
constant ERROR_DESCRIPTION = {"Invalid character encoding",
                              "Whitespace is not allowed at this location",
                              "Unexpected call, incomplete item still awaiting completion",
                              "Invalid outside of DTD",
                              "Invalid External ID",
                              "Expected string literal",
                              "Invalid character encountered in name",
                              "Expected equals sign",
                              "A reference was made to an undeclared namespace",
                              "End tag does not match start tag",
                              "This type of item is not valid within an element",
                              "eebax_StartDocument() must be called before any data is passed",
                              "Duplicate attributes in same element",
                              "Not valid in DTD"
                              }

constant DEFAULT_ENTITIES={{"lt"  ,"<"},
                           {"gt"  ,">"},
                           {"amp" ,"&" },
                           {"apos","\'"},
                           {"quot","\""}}
                           
constant WHITESPACE = {#20, #9, #D, #A}
constant RESERVED_CHARS = "<>&\'\""
-- END Local Constants

-- BEGIN Global variables
-- The next instance ID that will be used
integer NextHInst
NextHInst = 1
-- END Global variables

-- BEGIN Instance unique variables
-- These variables are all sequences containing a different value for each instance of the parser
-- All these sequences are parralel to eachother, so hInst[i] and Stack[i] will both relate to the same Instance

sequence hInst
-- The instance ID
hInst = {}

sequence Stack
-- Current open elements, when a element opens it is pushed onto the stack and when it closes it is poped from the stack
-- In the Uril, LocalName and QName examples bellow the value that would be generated by the following element is given:
-- Example element: <html:hr xmlns:html="http://www.w3.org/1999/xhtml"/>
constant stackURI        = 1, -- Namespace URI for the element, may be blank. Example: http://www.w3.org/1999/xhtml 
         stackLOCALNAME  = 2, -- Local name for the element. Example: hr
         stackQNAME      = 3, -- Qualified name for the element. Example: html:hr
         stackNSPREFIXES = 4  -- Namespace prefix mappings
constant BLANK_STACK = {"","","",{}}
Stack = {}

sequence Buffer
-- A buffer used to store data until there is enough to parse properly and generate an event
Buffer = {}

sequence PartialCharBuffer
-- Used when the begining of a UTF-8 multi-buyte character is encountered but the the string ends before all the bytes of the character have been read in.
PartialCharBuffer = {}

sequence Encoding
-- An atom value: -1 if the encoding is unknown, 8 if the encoding is UTF-8 or 16 if the encoding is UTF-16
-- NOTE: Always outputs xml in UTF-8 format
constant encodingUNKNOWN = 1,
         encodingUTF8    = 2,
         encodingUTF16BE = 3,
         encodingUTF16LE = 4
Encoding = {}

sequence Section
-- The current section being parsed
constant sectionMAIN                = 1, -- The main body of the XML document
         sectionINTERNALDTD         = 2, -- An internal DTD encapulsated inside a DOCTYPE element
         sectionEXTERNALDTD         = 3  -- An external DTD file
Section = {}

sequence State
-- A flag that indicates current parser state
constant stateERROR                  = -1,  -- A parser error has occured, exit the loop
         stateNOTSTARTED             = 0,  -- StartDocument has not yet been called
         stateCHARS                  = 1,  -- Normal character parseing
         stateTAGSTART               = 2,  -- A opening '<' has been encountered
         stateBANGTAG                = 3,  -- A tag starting with '<!' has been encountered
         stateCOMMENT                = 4,  -- A comment is being parsed
         stateCDATA                  = 5,  -- A CDATA element is being proccesed
         stateDOCTYPE                = 6,  -- A DOCTYPE element's name is being processed
         stateDTDREF                 = 7,  -- A reference to an external DTD is being processed
         statePROCESSINGINSTRUCTION  = 8,  -- The beginning of a processing instruction (tag starting with '<?') has been encountered
         stateOPENINGELEMENT         = 9,  -- The name from an element's beggining tag is being proccessed
         stateCLOSEELEMENT           = 10, -- A closing tag is being processed
         stateDTD                    = 11, -- A DTD is being proccessed, either an internal DTD or an external one inserted by the parser into the raw data
         stateDTDTAG                 = 12  -- A tag within a DTD is being proccessed
State = {}

sequence WithinString
-- -1 if not currently parseing a string or the string character being used ("'" or '"')
WithinString = {}

sequence Entities
-- A list entities
Entities = {}

sequence LineCount
-- The current line being proccessed, used for error reporting
LineCount = {}

-- Event handlers:
sequence onStartDocument
-- onStartDocument(integer hInst)
-- This event ocurs when a new document starts
onStartDocument = {}
sequence onEndDocument
-- onEndDocument(integer hInst)
-- This event ocurs when a document ends
onEndDocument = {}
sequence onStartElement
-- onStartElement(integer hInst,sequence Uri, sequence LocalName, sequence QName, sequence Atts)
-- This event ocurs when a new element starts. Atts is a sequence of attributes, for attribute x the following data can be retrieved:
-- Atts[x][EEBAX_ATTS_QNAME]     The qualified name of the attribute
-- Atts[x][EEBAX_ATTS_VALUE]     The value of the attribute
-- Atts[x][EEBAX_ATTS_URI]       The URI for the attribute
-- Atts[x][EEBAX_ATTS_LOCALNAME] The LocalName for the attribute
onStartElement = {}
sequence onEndElement
-- onEndElement(integer hInst,sequence Uri, sequence LocalName, sequence QName)
-- This event ocurs when a element ends
onEndElement = {}
sequence onStartPrefixMapping
-- onStartPrefixMapping(integer hInst,sequence Prefix, sequence Uri)
-- This event ocurs when a new namespace prefix mapping comes into scope
onStartPrefixMapping = {}
sequence onEndPrefixMapping
-- onEndPrefixMapping(integer hInst,sequence Prefix, sequence Uri)
-- This event ocurs when a namespace prefix mapping goes out of scope
onEndPrefixMapping = {}
sequence onCharacters
-- onCharacters(integer hInst,sequence Chars)
-- This event ocurs when character data is encountered
onCharacters = {}
sequence onIgnorableWhitespace
-- onIgnorableWhitespace(integer hInst, sequence Whitespace)
-- This event occurs when white space is encountered between elements
onIgnorableWhitespace = {}
sequence onProcessingInstruction
-- onProcessingInstruction(integer hInst,sequence Target, sequence Data)
-- This event ocurs when a processing instruction is encountered
onProcessingInstruction = {}
sequence onComment
-- onComment(integer hInst,sequence Comment)
-- This event ocurs when a comment is encountered
onComment = {}
sequence onParseError
-- onParseError(integer hInst, integer ErrorNumber, sequence Description, integer LineNumber)
-- This event ocurs when a parseing error occurs.
-- ErrorNumber is numerical error code
-- Description is a textual description that could be shown to a user
-- LineNumber is the current line number and should be used for error reporting
onParseError = {}
sequence onXML
-- onXML(integer hInst, sequence XML)
-- This event ocurs when ever a piece of XML is parsed, the XML attribute contains the raw XML that has just been parsed (will be used for XML output later on).
onXML = {}
sequence onLoadExternal
-- onLoadExternal(integer hInst, integer Public, sequence URI)
-- This event occurs when a external reference is made, the application should load the resource and pass it to eebax_Parse().
-- Public will be TRUE if the URI is a public identifier, otherwise the URI is a SYSTEM identifier (a filename)
onLoadExternal = {}
-- END Instance unique variables

-- BEGIN Utility routines

--Cut an element from a sequence
function cutseq(sequence s, integer i)
    return s[1..i-1]&s[i+1..length(s)]
end function

-- END Utility routines

-- BEGIN Set<Event> procedures

-- eebax_SetStartDocumentEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a new document is started
-- See also: StartElement event
global procedure eebax_SetStartDocumentEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onStartDocument[index] = RoutineID
end procedure

-- eebax_SetEndDocumentEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when the document closes
-- See also: EndElement event
global procedure eebax_SetEndDocumentEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onEndDocument[index] = RoutineID
end procedure

-- eebax_SetStartElementEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a new element is started
-- See also: StartElement event
global procedure eebax_SetStartElementEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onStartElement[index] = RoutineID
end procedure

-- eebax_SetEndElementEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when an element closes
-- See also: EndElement event
global procedure eebax_SetEndElementEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onEndElement[index] = RoutineID
end procedure

-- eebax_SetStartPrefixMappingEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a new namespace prefix mapping comes into scope
-- See also: StartPrefixMapping event
global procedure eebax_SetStartPrefixMappingEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onStartPrefixMapping[index] = RoutineID
end procedure

-- eebax_SetEndPrefixMappingEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a new namespace prefix mapping goes out of scope
-- See also: EndPrefixMapping event
global procedure eebax_SetEndPrefixMappingEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onEndPrefixMapping[index] = RoutineID
end procedure

-- eebax_SetCharactersEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when character data is encountered.
-- See also: Characters event
global procedure eebax_SetCharactersEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onCharacters[index] = RoutineID
end procedure

-- eebax_SetCharactersEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when character data is encountered.
-- See also: Characters event
global procedure eebax_SetIgnorableWhitespaceEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onIgnorableWhitespace[index] = RoutineID
end procedure

-- eebax_SetProcessingInstructionEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a processing instruction is encountered
-- See also: ProcessingInstruction event
global procedure eebax_SetProcessingInstructionEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onProcessingInstruction[index] = RoutineID
end procedure

-- eebax_SetCommentEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a comment is encountered
-- See also: Comment event
global procedure eebax_SetCommentEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onComment[index] = RoutineID
end procedure

-- eebax_SetParseErrorEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when an error occurs in the XML being parsed.
-- See also: ParseError event
global procedure eebax_SetParseErrorEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onParseError[index] = RoutineID
end procedure

-- eebax_SetXMLEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called for each piece of XML parsed.
-- See also: XML event
global procedure eebax_SetXMLEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onXML[index] = RoutineID
end procedure

-- eebax_SetLoadExternalEvent(integer hInst,atom RoutineID)
-- Sets the routine that will be called when a external uri is referenced in the document.
-- See also: LoadExternal event
global procedure eebax_SetLoadExternalEvent(integer hinst,atom RoutineID)
    atom index
    index = find(hinst,hInst)
    onLoadExternal[index] = RoutineID
end procedure

-- END Set<Event> procedures

-- BEGIN Parser utilitys

-- eebax_DecodeUTF8(sequence Data)
-- Decodes a UTF-8 encoded string so that each character occupies one element of a sequence
-- If the string comes to a premature end then a atom containing a negative number which is the distance from the end of the string that the cut off multibyte character started at
-- If any other error is encountered then an atom containing the character that caused the error is returned
global function eebax_DecodeUTF8(sequence Data)
    atom i,l,v
    sequence ret
    i = 1
    ret = ""
    while i <= length(Data) do
        if and_bits(Data[i],#80) = 0 then
            --1 byte
            l = 1
        elsif and_bits(Data[i],#20)= 0 then
            --2 byte
            l = 2
        elsif and_bits(Data[i],#10)= 0 then
            --3 byte
            l = 3
        elsif and_bits(Data[i],#8)= 0 then
            --4 bytes
            l = 4
        elsif and_bits(Data[i],#4)= 0 then
            --5 bytes
            l = 5
        elsif and_bits(Data[i],#2)= 0 then
            --6 bytes
            l = 6
        else
            --Error
            return i
        end if
        Data[i] = and_bits(power(2,8-l)-1,Data[i])
        if i + l - 1 > length(Data) then
            return i-length(Data)
        end if
        v = 0
        
        for n = 0 to l-1 do
            if n != 0 then
                Data[i+n] = and_bits(Data[i+n],63)
            end if
            v += Data[i+n]*power(64,(l-1)-n)
        end for
        ret &= v
        i += l
    end while
    return ret
end function

-- eebax_DecodeUTF16(sequence Data)
-- Decodes a UTF-16 encoded string so that each character occupies one element of a sequence
-- The first character of data should be the #FEFF marker (BOM)
-- If the string comes to a premature end then a atom containing a negative number which is the distance from the end of the string that the cut off multibyte character started at
-- If any other error is encountered then an atom containing the character that caused the error is returned
global function eebax_DecodeUTF16(sequence Data)
    integer i,W1,W2
    integer BigEndian
    sequence ret
    
    -- Check the length of the string is devisible by 4 (if it isn't then we're missing a character)
    if length(Data)/2 != floor(length(Data)/2) or length(Data) < 2 then
        return 0 -- 0 indicates that the string came to premature end 0 bytes from the end
    elsif length(Data) < 4 then
        return {}
    end if
    
    if equal(Data[1..2],{#FE,#FF}) then
        BigEndian = 1
    elsif equal(Data[1..2],{#FF,#FE}) then
        BigEndian = 0
    else
        return 1 -- Indicate error in first byte
    end if
    Data = Data[3..length(Data)]
    
    i = 1
    ret = ""
    while i+1 <= length(Data) do
        if BigEndian then
            W1 = bytes_to_int({Data[i+1],Data[i],0,0})
        else
            W1 = bytes_to_int({Data[i],Data[i+1],0,0})
        end if
        if W1 < #D800 or W1 > #DFFF then
            ret &= W1
        elsif length(Data) >= i+3 then -- Make sure there is another 16 bit pair
            i += 2 -- In addition to the 2 added at the end of the loop because this character is *4* bytes wide
            if not (i+1 <= length(Data)) then
                return (i-2)-length(Data)
            end if
            if BigEndian then
                W2 = bytes_to_int({Data[i+1],Data[i],0,0})
            else
                W2 = bytes_to_int({Data[i],Data[i+1],0,0})
            end if
            if W2 < #DC00 or W2 > #DFFF then
                -- An error has been encountered, this is not a valid UTF-16 string
                return i -- Return location of error
            end if
            ret &= and_bits(#FFFFF,W1*1024+and_bits(#3FF,W2))+#10000
        else
            -- Error
            return length(Data)-i -- Return a atom <= 0 indicating premature end of character starting at length of string minus the return value
        end if
        i += 2
    end while
    return ret
end function

-- eebax_EncodeUTF8(sequence Data)
-- Encodes a unicode string where each character occupies one element of a sequence into a UTF-8 encoded string.
-- If an error is encountered then an atom containing the character that caused the error is returned
global function eebax_EncodeUTF8(sequence Data)
    atom l,mask
    sequence ret,bytes
    ret = ""
    for i = 1 to length(Data) do
        if Data[i] <= #7F then
            -- 1 byte needed, compatible with ascii
            l = 1
        elsif Data[i] <= #7FF then
            -- 2 bytes needed
            l = 2
            mask = #C0 -- 110xxxxx
        elsif Data[i] <= #FFFF then
            -- 3 bytes needed
            l = 3
            mask = #E0 -- 11100000
        elsif Data[i] <= #1FFFF then
            -- 4 bytes needed
            l = 4
            mask = #F0 -- 11110000
        elsif Data[i] <= #3FFFFFF then
            -- 5 bytes needed
            l = 5
            mask = #F8 -- 11111000
        elsif Data[i] <= #7FFFFFFF then
            -- 6 bytes needed
            l = 6
            mask = #FC -- 11111100
        else
            -- Error
            return i
        end if
        if l = 1 then
            -- Shortcut, most data will probably be ok to represent in one byte
            ret &= Data[i]
        else
            -- Encode the first byte, this includes the byte count
            bytes = {}
            for n = 1 to l do
                bytes &= and_bits(floor(Data[i]/power(64,l-n)),63)+128
            end for
            bytes[1] = or_bits(mask,bytes[1])
            ret &= bytes
        end if
    end for
    return ret
end function

-- eebax_EncodeUTF16(sequence Data
-- Encodes a unicode string where each character occupies one element of a sequence into a UTF-16 encoded string (including 2 byte BOM)
-- If an error is encountered then an atom containing the character that caused the error is returned
global function eebax_EncodeUTF16(sequence Data)
    sequence ret
    ret = {#FF,#FE} -- We're encoding in little endian format (it's the format that x86 proccessors use)
    for i = 1 to length(Data) do
        if Data[i] > #10FFFF then
            return i -- Error
        elsif Data[i] < #10000 then
            ret &= int_to_bytes(Data[i])
            ret = ret[1..length(ret)-2]
        else
            Data[i] = Data[i] - #10000
            --W1 = (#D800+floor(Data[i]/1024))
            --W2 = (#DC00+and_bits(#FF,Data[i]))
            ret &= int_to_bytes((#DC00+and_bits(#FF,Data[i]))*#10000+(#D800+floor(Data[i]/1024)))
        end if
    end for
    return ret
end function

function DecodeUTF(integer hinst,sequence Data)
    atom index
    object ret
    integer chardatastart -- normaly 0, but 3 if a UTF-16 BOM was passed along with data
    index = find(hinst,hInst)
    
    chardatastart = 0
    if Encoding[index] = encodingUNKNOWN then
        if length(Data) < 1 then
            return 0 -- Premature end
        end if
        if find(Data[1],{#FE,#FF}) then
            -- UTF-16
            -- Data[1..2] must equal BOM
            if length(Data) < 2 then
                return -(length(Data)-1) -- Premature end
            end if
            if equal(Data[1..2],{#FE,#FF}) then
                -- UTF-16 BIG ENDIAN
                Encoding[index] = encodingUTF16BE
                chardatastart = 3
                Data = Data[3..length(Data)]
            elsif equal(Data[1..2],{#FF,#FE}) then
                -- UTF-16 LITTLE ENDIAN
                Encoding[index] = encodingUTF16LE
                chardatastart = 3
                Data = Data[3..length(Data)]
            else
                Encoding[index] = encodingUTF8
            end if
        else
            -- UTF-8
            Encoding[index] = encodingUTF8
        end if
    end if
    
    if Encoding[index] = encodingUTF8 then
        -- UTF-8
        ret = eebax_DecodeUTF8(Data)
    elsif Encoding[index] = encodingUTF16BE then
        -- UTF-16 BE
        ret = eebax_DecodeUTF16({#FE,#FF}&Data)
    else
        -- UTF-16 LE
        ret = eebax_DecodeUTF16({#FF,#FE}&Data)
    end if
    
    if atom(ret) and  ret > 0 then
        ret += chardatastart
    end if
    return ret
end function

-- Replaces entities with there values in passed string
function UnescapeChars(integer hinst, sequence string)
    atom index
    sequence newstring,esc
    integer startloc,endloc
    index = find(hinst,hInst)
    
    newstring = ""
    while 1 do
        startloc = find('&',string)
        endloc = find(';',string)
        if startloc = 0 or endloc < 2 or startloc > endloc then
            newstring = newstring & string
            exit
        end if
        esc = string[startloc+1..endloc-1]
        newstring = newstring & string[1..startloc-1]
        string = string[endloc+1..length(string)]
        if esc[1] = '#' then
            if length(esc) > 1 then
                if esc[2] = 'x' then
                    esc = "#"&esc[3..length(esc)]   
                else
                    esc = esc[2..length(esc)]   
                end if
                esc = value(upper(esc)) 
                newstring = newstring & esc[2]
            end if
        else
            for i = 1 to length(Entities[index]) do
                if equal(esc,Entities[index][i][1]) then
                    newstring = newstring & Entities[index][i][2]
                    exit
                end if
            end for
        end if
    end while
    return newstring
end function

function EscapeChars(integer hinst,sequence string)
    atom index
    sequence newstring    
    index = find(hinst,hInst)
    
    newstring = ""
    for i = 1 to length(string) do
        if find(string[i],RESERVED_CHARS) then
            for n = 1 to length(Entities[index]) do
                if Entities[index][n][2][1] = string[i] then
                    newstring = newstring & "&"&Entities[index][n][1]&";"
                    exit
                end if
            end for
        else
            --this char is ok
            newstring = newstring & string[i]
        end if
    end for
    return newstring
end function

function MapPrefix(integer hinst, sequence prefix)
    atom index
    index = find(hinst,hInst)
    
    -- Search for prefix mapping...
    for i = length(Stack[index]) to 1 by -1 do
        for n = 1 to length(Stack[index][i][stackNSPREFIXES]) do
            if equal(Stack[index][i][stackNSPREFIXES][n][1],prefix) then
                return Stack[index][i][stackNSPREFIXES][n][2]
            end if
        end for
    end for
    
    -- No mapping found, if the prefix being searched for is the default (zero length string) then
    -- return zero length string if not then return -1 to indicated failure
    if length(prefix) = 0 then
        return ""
    elsif equal(prefix,"xml") then
        -- The prefix xml is by definition bound to the namespace name http://www.w3.org/XML/1998/namespace
        return "http://www.w3.org/XML/1998/namespace"
    elsif equal(prefix,"xmlns") then
        -- The prefix xmlns is used only for namespace bindings and is not itself bound to any namespace name.
        return ""
    else
        return -1
    end if
end function

-- Returns {URI,LocalName}
function ExpandQName(integer hinst, sequence QName) 
    atom index
    atom loc
    index = find(hinst,hInst)
    
    loc = find(':',QName)
    if loc != 0 and length(QName) != loc then
        return {MapPrefix(hInst[index],QName[1..loc-1]),QName[loc+1..length(QName)]}
    else
        return {MapPrefix(hInst[index],""),QName}
    end if
end function

function ltrim(sequence s)
    -- discard leading whitespace of sequence s
    for i = 1 to length(s) do
        if not find(s[i], WHITESPACE) then  return s[i..length(s)] end if
    end for
    return {}
end function

function rtrim(sequence s)
    -- discard trailing whitespace of sequence s
    for i = length(s) to 1 by -1 do
        if not find(s[i], WHITESPACE) then  return s[1..i] end if
    end for
    return {}
end function

function trim(sequence s)
    -- discard leading and trailing whitespace of sequence s
    return ltrim(rtrim(s))
end function

-- END Parser utitiltys

-- BEGIN Raise<Event> procedures
procedure RaiseStartDocumentEvent(integer hinst)
    atom index
    index = find(hinst,hInst)
    if onStartDocument[index] != -1 then
        call_proc(onStartDocument[index],{hInst[index]})
    end if
end procedure

procedure RaiseEndDocumentEvent(integer hinst)
    atom index
    index = find(hinst,hInst)
    if onEndDocument[index] != -1 then
        call_proc(onEndDocument[index],{hInst[index]})
    end if
end procedure

procedure RaiseStartElementEvent(integer hinst,sequence Uri, sequence LocalName, sequence QName, sequence Atts)
    atom index
    index = find(hinst,hInst)
    if onStartElement[index] != -1 then
        call_proc(onStartElement[index],{hInst[index], Uri, LocalName, QName, Atts})
    end if
end procedure

procedure RaiseEndElementEvent(integer hinst,sequence Uri, sequence LocalName, sequence QName)
    atom index
    index = find(hinst,hInst)
    if onEndElement[index] != -1 then
        call_proc(onEndElement[index],{hInst[index], Uri, LocalName, QName})
    end if
end procedure

procedure RaiseStartPrefixMappingEvent(integer hinst, sequence URI, sequence Prefix)
    atom index
    index = find(hinst,hInst)
    if onStartPrefixMapping[index] != -1 then
        call_proc(onStartPrefixMapping[index],{hInst[index], URI,Prefix})
    end if
end procedure

procedure RaiseCharactersEvent(integer hinst,sequence Chars)
    atom index
    index = find(hinst,hInst)
    if onCharacters[index] != -1 then
        call_proc(onCharacters[index],{hInst[index], Chars})
    end if
end procedure

procedure RaiseIgnorableWhitespaceEvent(integer hinst,sequence Whitespace)
    atom index
    index = find(hinst,hInst)
    if onIgnorableWhitespace[index] != -1 then
        call_proc(onIgnorableWhitespace[index],{hInst[index], Whitespace})
    end if
end procedure

procedure RaiseParseErrorEvent(integer hinst, integer ErrorNumber)
    atom index
    index = find(hinst,hInst)
    State[index] = stateERROR
    if onParseError[index] != -1 then
        call_proc(onParseError[index],{hInst[index], ErrorNumber, ERROR_DESCRIPTION[ErrorNumber], LineCount[index]})
    end if
    --abort(1/0) -- Can be useful for tracking bugs sometimes...
end procedure

procedure RaiseProcessingInstructionEvent(integer hinst, sequence Target, sequence Data)
    atom index
    index = find(hinst,hInst)
    if onProcessingInstruction[index] != -1 then
        call_proc(onProcessingInstruction[index],{hInst[index], Target, Data})
    end if
end procedure

procedure RaiseCommentEvent(integer hinst, sequence Comment)
    atom index
    index = find(hinst,hInst)
    if onComment[index] != -1 then
        call_proc(onComment[index],{hInst[index], Comment})
    end if
end procedure

procedure RaiseXMLEvent(integer hinst, sequence XML)
    atom index
    index = find(hinst,hInst)
    if onXML[index] != -1 then
        call_proc(onXML[index],{hInst[index], eebax_EncodeUTF8(XML)})
    end if
end procedure

procedure RaiseLoadExternalEvent(integer hinst, integer Public, sequence URI)
    atom index
    index = find(hinst,hInst)
    if onLoadExternal[index] != -1 then
        call_proc(onLoadExternal[index],{hInst[index], Public, URI})
    end if
end procedure

-- END Raise<Event> procedures

-- BEGIN Parser control

procedure CreateInstance(integer hinst)
    atom index
    index = length(hInst)+1
    hInst                   &= hinst
    Stack                    = append(Stack,{})
    Buffer                   = append(Buffer,"")
    PartialCharBuffer        = append(PartialCharBuffer,"")
    Encoding                &= encodingUNKNOWN
    Section                 &= sectionMAIN
    State                   &= stateNOTSTARTED
    WithinString            &= -1
    Entities                 = append(Entities,DEFAULT_ENTITIES)
    LineCount               &= 1
    onStartDocument         &= -1
    onEndDocument           &= -1
    onStartElement          &= -1
    onEndElement            &= -1
    onStartPrefixMapping    &= -1
    onEndPrefixMapping      &= -1
    onCharacters            &= -1
    onIgnorableWhitespace   &= -1
    onProcessingInstruction &= -1
    onComment               &= -1
    onParseError            &= -1
    onXML                   &= -1
    onLoadExternal          &= -1
end procedure

-- integer eebax_NewInstance()
-- Creates a new instance of the parser and returns a handle
-- See also: eebax_DestroyInstance(),eebax_ResetInstance()
global function eebax_NewInstance()
    CreateInstance(NextHInst)
    NextHInst += 1 --Incrases the NextHInst counter
    return NextHInst-1
end function

-- eebax_DestroyInstance(integer hInst)
-- Destroys the instance and all it's data structures
-- See also: eebax_NewInstance(),eebax_ResetInstance()
global procedure eebax_DestroyInstance(integer hinst)
    atom index
    index = find(hinst,hInst)
    --Remove all instance unique variables used by this instance
    hInst                   = cutseq(hInst,index)
    Stack                   = cutseq(Stack,index)
    Buffer                  = cutseq(Buffer,index)
    PartialCharBuffer       = cutseq(PartialCharBuffer,index)
    Encoding                = cutseq(Encoding,index)
    Section                 = cutseq(Section,index)
    State                   = cutseq(State,index)
    WithinString            = cutseq(WithinString,index)
    Entities                = cutseq(Entities,index)
    LineCount               = cutseq(LineCount,index)
    onStartDocument         = cutseq(onStartDocument,index)
    onEndDocument           = cutseq(onEndDocument,index)
    onStartElement          = cutseq(onStartElement,index)
    onEndElement            = cutseq(onEndElement,index)
    onStartPrefixMapping    = cutseq(onStartPrefixMapping,index)
    onEndPrefixMapping      = cutseq(onEndPrefixMapping,index)
    onCharacters            = cutseq(onCharacters,index)
    onIgnorableWhitespace   = cutseq(onIgnorableWhitespace,index)
    onProcessingInstruction = cutseq(onProcessingInstruction,index)
    onComment               = cutseq(onComment,index)
    onParseError            = cutseq(onParseError,index)
    onXML                   = cutseq(onXML,index)
    onLoadExternal          = cutseq(onLoadExternal,index)
end procedure

-- eebax_ResetInstance(integer hInst)
-- Resets the instance so that it can be used again
-- Once reset the instance will behave exactly as if it had just been created with eebax_NewInstance except all the events that have been set will be left in tact.
-- See also: eebax_NewInstance(), eebax_DestroyInstance()
global procedure eebax_ResetInstance(integer hinst)
    atom index
    index = find(hinst,hInst)
    State[index] = stateNOTSTARTED
    -- Initialization of all variables will be handled in the eebax_StartDocument...
end procedure

-- END Parser control

-- BEGIN XML Creation procedures

-- eebax_StartDocument(integer hInst)
-- Starts a new document.
global procedure eebax_StartDocument(integer hinst)
    atom index
    index = find(hinst,hInst)

    if State[index] != stateNOTSTARTED then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if
    
    -- Reset all variables for the instance
    Stack[index]             = {}
    Buffer[index]            = ""
    PartialCharBuffer[index] = ""
    Encoding[index]          = encodingUNKNOWN
    Section[index]           = sectionMAIN
    WithinString[index]      = -1
    Entities[index]          = DEFAULT_ENTITIES 
    LineCount[index]         = 1
    
    State[index] = stateCHARS
    
    RaiseStartDocumentEvent(hInst[index])
end procedure

-- eebax_EndDocument(integer hInst)
-- Ends the current document. Should be called after a document has been parsed or created, will generate errors if the document was not complete.
global procedure eebax_EndDocument(integer hinst)
    atom index
    index = find(hinst,hInst)
    
    if State[index] != stateCHARS or length(Stack[index]) != 0 then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        -- Even if an error occured we should still reinitialize the instance
    end if
    
    -- Reset the instance so it can parse another document
    eebax_ResetInstance(hInst[index])
    RaiseEndDocumentEvent(hInst[index])
end procedure

-- eebax_StartElement(integer hInst, sequence name, sequence atts, integer empty)
-- Starts a new element
-- name is a qualified name for the new element
-- atts is a list of attributes in the form of a sequence of {name,value} sequences were name is a qualified name
-- empty is a boolean value to indicate if the tag is empty (in which case it will be output in the form <name atts/>)
-- If the empty flag is true then eebax_EndElement should and can not be called for this element
-- Name space declarations can be supplied in the attribute list
global procedure eebax_StartElement(integer hinst, sequence qname, sequence atts, integer empty)
    atom index
    sequence nsprefix,xml,elementinfo
    index = find(hinst,hInst)
    
    -- Add element stack entry for this element
    Stack[index] = append(Stack[index],BLANK_STACK)
    
    -- This error could only ever happen if a user called this routine directly
    if State[index] != stateCHARS then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if
    
    -- Check for namespace declarations
    for i = 1 to length(atts) do
        if equal(atts[i][EEBAX_ATTS_QNAME],"xmlns") or match("xmlns:",atts[i][EEBAX_ATTS_QNAME]) = 1 then
            if equal(atts[i][EEBAX_ATTS_QNAME],"xmlns") then
                nsprefix = {"", atts[i][EEBAX_ATTS_VALUE]}
            else
                nsprefix = {atts[i][EEBAX_ATTS_QNAME][7..length(atts[i][EEBAX_ATTS_QNAME])], atts[i][EEBAX_ATTS_VALUE]}
            end if
            Stack[index][length(Stack[index])][stackNSPREFIXES] &= {nsprefix}
            RaiseStartPrefixMappingEvent(hInst[index],
                                         nsprefix[2],
                                         nsprefix[1])
        end if
    end for
    
    -- Fill in the name parts of the stack entry
    qname = ExpandQName(hInst[index],qname)&{qname}
    Stack[index][length(Stack[index])][stackURI]       = qname[1]
    Stack[index][length(Stack[index])][stackLOCALNAME] = qname[2]
    Stack[index][length(Stack[index])][stackQNAME]     = qname[3]
    
    if atom(Stack[index][length(Stack[index])][stackURI]) then
        if FULL_NAMESPACE_CHECKING then
            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNDECLARED_NAMESPACE)
            return
        else
            Stack[index][length(Stack[index])][stackURI] = MapPrefix(hInst[index],"")
        end if
    end if
    
    -- Add EEBAX_ATTS_URI and EEBAX_ATTS_LOCALNAME elements to Atts sequence
    for i = 1 to length(atts) do
        -- Maybe the user passed atts that allready had URI and LocalName properties, we should replace those
        atts[i] = atts[i][1..2] & ExpandQName(hInst[index],atts[i][EEBAX_ATTS_QNAME])        
        if atom(atts[i][EEBAX_ATTS_URI]) then
            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNDECLARED_NAMESPACE)
            return
        end if
    end for
    
    RaiseStartElementEvent(hInst[index],
                           Stack[index][length(Stack[index])][stackURI],
                           Stack[index][length(Stack[index])][stackLOCALNAME],
                           Stack[index][length(Stack[index])][stackQNAME],
                           atts)
    
    -- Generate XML:}
    if onXML[index] != -1 then
        xml = "<"&Stack[index][length(Stack[index])][stackQNAME]
        for i = 1 to length(atts) do
            xml &= " " & atts[i][EEBAX_ATTS_QNAME] & "=\"" & EscapeChars(hInst[index],atts[i][EEBAX_ATTS_VALUE]) & "\""
        end for
        if empty then
            xml &= "/"
        end if
        xml &= ">"
        RaiseXMLEvent(hInst[index],xml)
    end if
    
    -- If this is an empty element then raise the EndElement event and remove the element from the stack now
    if empty then
        elementinfo = Stack[index][length(Stack[index])]
        RaiseEndElementEvent(hInst[index], elementinfo[stackURI], elementinfo[stackLOCALNAME], elementinfo[stackQNAME])
        Stack[index] = Stack[index][1..length(Stack[index])-1]
    end if
end procedure

-- eebax_EndElement(integer hInst, sequence name)
-- Starts a new element
-- name is a qualified name for the element being closed
global procedure eebax_EndElement(integer hinst, sequence qname)
    atom index
    sequence elementinfo
    index = find(hinst,hInst)
    
    -- This error could only ever happen if a user called this routine directly
    if State[index] != stateCHARS then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if
    
    -- Check that the end tag matches the start tag
    if length(Stack[index]) = 0 or not equal(qname,Stack[index][length(Stack[index])][stackQNAME]) then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_END_TAG_DOES_NOT_MATCH)
        return
    end if
    
    elementinfo = Stack[index][length(Stack[index])]
    Stack[index] = Stack[index][1..length(Stack[index])-1]
    
    -- Generate XML:
    RaiseXMLEvent(hInst[index],"</"&elementinfo[stackQNAME]&">")
    
    RaiseEndElementEvent(hInst[index], elementinfo[stackURI], elementinfo[stackLOCALNAME], elementinfo[stackQNAME])
end procedure

-- eebax_Characters(integer hInst, sequence Chars)
-- Adds Data to the current document as character data. Chars should be unescaped character data.
global procedure eebax_Characters(integer hinst, sequence Chars)
    atom index
    index = find(hinst,hInst)

    -- This error could only ever happen if a user called this routine directly
    if State[index] != stateCHARS then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if        
    
    RaiseCharactersEvent(hInst[index],Chars)
    -- Generate XML:
    if onXML[index] != -1 then
        -- UTF-8 encoding is done by RaiseXMLEvent
        RaiseXMLEvent(hInst[index],EscapeChars(hInst[index],Chars))
    end if
end procedure

-- eebax_ProcessingInstruction(integer hInst, sequence Target, sequence Data)
-- Generates a processing instruction.
global procedure eebax_ProcessingInstruction(integer hinst, sequence Target, sequence Data)
    atom index
    index = find(hinst,hInst)
    
    -- This error could only ever happen if a user called this routine directly
    if State[index] != stateCHARS then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if  
    
    RaiseProcessingInstructionEvent(hInst[index], Target, Data)
    -- Generate XML:
    -- Ensure that if data exists there is a space between it and the Target
    if length(Data) > 0 then Data &= " " end if
    RaiseXMLEvent(hInst[index],"<?"&Target&" "&Data&"?>")
end procedure

-- eebax_Comment(integer hInst, sequence Comment)
-- Adds Comment to the current document as a comment.
global procedure eebax_Comment(integer hinst, sequence Comment)
    atom index
    index = find(hinst,hInst)
    
    -- This error could only ever happen if a user called this routine directly
    if State[index] != stateCHARS then
        RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_UNEXPECTED)
        return
    end if  
    
    RaiseCommentEvent(hInst[index],Comment)
    -- Generate XML:
    RaiseXMLEvent(hInst[index],"<!--"&Comment&"-->")
end procedure

-- END XML Creation procedures

-- BEGIN Parse routines

procedure ParseProcessingInstruction(integer hinst,sequence Data)
    atom index
    sequence Target
    index = find(hinst,hInst)
    
    Target = Data
    Data = ""
    -- Seperate the data from the target
    for i = 1 to length(Target) do
        if find(Target[i],WHITESPACE) then
            Data = Target[i+1..length(Target)]
            Target = Target[1..i-1]
            exit
        end if
    end for
    -- Raise the event
    eebax_ProcessingInstruction(hInst[index], Target, Data)
end procedure

procedure ParseOpeningElement(integer hinst, sequence Data)
    atom index
    sequence name,atts,attname,attvalue
    index = find(hinst,hInst)
    
    -- Blocks of spaces have been normalized to a space " "
    
    Data &= ">"
    
    -- Get the name
    for i = 1 to length(Data) do
        if find(Data[i] ," />") then
            name = Data[1..i-1]
            Data = ltrim(Data[i..length(Data)])
            exit
        end if
    end for
    
    -- Get the attributes
    attname = {}
    attvalue = {}
    while length(Data) > 0 do
        -- Check if this is the end of the attributes
        if find(Data[1],"/>") then
            exit
        end if
        
        -- Read in attribute name
        for i = 1 to length(Data) do
            if find(Data[i]," =") then
                attname = append(attname,Data[1..i-1])
                if find(attname[length(attname)],attname) != length(attname) then
                    -- This attribute has allready been defined
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_DUPLICATE_ATT)
                    return
                end if
                if length(attname[length(attname)]) = 0 then
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_NAME_CHAR)
                    return
                end if
                Data = ltrim(Data[i..length(Data)])
                if Data[1] != '=' then
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_EXPECTED_EQUAL)
                    return
                end if
                --Remove the equals sign and any further spaces after it
                Data = ltrim(Data[2..length(Data)])
                if find(Data[1],"\"'") then
                    exit
                else
                    -- Not a string
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_EXPECTED_STRING_LITERAL)
                    return
                end if
            elsif find(Data[i],">/") then
                RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_NAME_CHAR)
                return
            end if
        end for
        
        -- Check if attribute pair was found
        if find(Data[1],"\"\'") then
            -- Another item name was read in, read in value
            for i = 2 to length(Data) do
                if Data[i] = Data[1] then
                    -- Add the value 
                    attvalue = append(attvalue,UnescapeChars(hInst[index],Data[2..i-1]))
                    Data = ltrim(Data[i+1..length(Data)])
                    exit
                end if
            end for
        end if
    end while
    
    -- Combine names values
    atts = {}
    for i = 1 to length(attname) do
        atts = append(atts,{attname[i],attvalue[i]})
    end for

    -- Add the element to the document
    eebax_StartElement(hInst[index],name,atts,Data[1] = '/')
end procedure

procedure ParseCharacters(integer hinst, sequence Data)
    atom index
    sequence LeadingWhitespace, TrailingWhitespace
    index = find(hinst,hInst)

    -- Strip leading whitespace and send it to IgnorableWhitespace
    LeadingWhitespace = ""
    for i = 1 to length(Data) do
        if not find(Data[i],WHITESPACE) then
            exit
        else
            LeadingWhitespace &= Data[i]
        end if
    end for
    Data = Data[length(LeadingWhitespace)+1..length(Data)]
    
    -- Find trailing whitespace
    TrailingWhitespace = ""
    for i = length(Data) to 1 by -1 do
        if not find(Data[i],WHITESPACE) then
            exit
        else
            TrailingWhitespace = Data[i] & TrailingWhitespace
        end if
    end for
    Data = Data[1..length(Data)-length(TrailingWhitespace)]
    
    if length(LeadingWhitespace) > 0 then
        RaiseIgnorableWhitespaceEvent(hInst[index],LeadingWhitespace)
        RaiseXMLEvent(hInst[index],LeadingWhitespace)
    end if
    
    if length(Data) > 0 then
        eebax_Characters(hInst[index],Data)
    end if
    
    if length(TrailingWhitespace) > 0 then
        RaiseIgnorableWhitespaceEvent(hInst[index],TrailingWhitespace)
        RaiseXMLEvent(hInst[index],TrailingWhitespace)
    end if
end procedure

procedure ParseDTDTag(integer hinst, sequence Data)
    -- Add DTD stuff here
    
    -- Get rid of (parameters not used) warning without turning warnings of
    hinst = hinst
    Data = Data
end procedure

-- eebax_Parse(integer hInst,sequence Data)
-- Parses XML Data and generates apropriate events. Returns 0 if an error occurs or 1 if no error occurs during the parseing of Data, use the ParseError event to get full error info.
-- UTF-16 documents must be read in in binary mode *NOT* text mode, UTF-8 *SHOULD* be ok with either
global function eebax_Parse(integer hinst,sequence data)
    atom index
    object Data
    object temp -- only for places where variable is needed very briefly
    index = find(hinst,hInst)
    
    -- If there are any partial UTF-8 chars in the PartialCharBuffer then add them to the begining of data
    data = PartialCharBuffer[index]&data
    PartialCharBuffer[index] = ""
    
    if length(data) = 0 then return 1 end if
    
    --Data may include characters above 128 represented using UTF-8, decode them here:
    Data = DecodeUTF(hinst,data)
    if atom(Data) then
        if Data > 0 then
            -- An encoding error was encountered
            -- Find the line number of the given error-causing character
            for i = 1 to Data do
                if data[i] = '\n' then
                    --Add one to the line count
                    LineCount[index] += 1
                end if
            end for
            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_CHARACTER_ENCODING)
            return 0
        else
            -- The string came to a premature end
            -- Data will be negative or 0 and length(data)+Data will be the position of the incomplete character
            -- First proccess all the data up to the partial character
            if eebax_Parse(hInst[index],data[1..length(data)+Data-1]) then
                -- Now store the partial character so that when the other parts of it are sent in they can be reunited :)
                PartialCharBuffer[index] = data[length(data)+Data..length(data)]&PartialCharBuffer[index]
                return 1
            else
                return 0
            end if
        end if
    end if
    
    for i = 1 to length(Data) do
        --Global stuff that should be done whatever the state
        if Data[i] = '\n' and Section[index] != sectionEXTERNALDTD then
            --Add one to the line count
            LineCount[index] += 1
        end if
        
        -- Check the current state and act acordingly
        -- First check if it's CR character which should be ignored
        -- Then check if a string is being parsed, the code for this is the same for any state
        if Data[i] = 13 then
            -- Ignore character
        elsif WithinString[index] != -1 then
            Buffer[index] &= Data[i]
            if Data[i] = WithinString[index] then
                -- End of string has been reached
                WithinString[index] = -1
            end if
        elsif State[index] = stateERROR then
            return 0
        elsif State[index] = stateNOTSTARTED then
            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_STARTDOCUMENT_NOT_CALLED)
            return 0
        elsif State[index] = stateCHARS then
            if Data[i] = '<' then
                -- A tags opening bracket has been encountered, if there was any character data between the last tag and this one then flush it
                if length(Buffer[index]) >0 then
                    ParseCharacters(hInst[index],UnescapeChars(hInst[index],Buffer[index]))
                    -- Clear the buffer
                    Buffer[index] = ""
                end if
                -- Change the state
                State[index] = stateTAGSTART
            else
                Buffer[index] &= Data[i]
            end if
        elsif State[index] = stateTAGSTART then
            if Data[i] = '!' then
                State[index] = stateBANGTAG
            elsif Data[i] = '?' then
                State[index] = statePROCESSINGINSTRUCTION
            elsif find(Data[i],WHITESPACE) then
                --Raise an error (whitespace is not allowed before tag name)
                RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_WHITESPACE)
                return 0
            elsif Data[i] = '/' then
                Buffer[index] = ""
                State[index] = stateCLOSEELEMENT
            else
                -- This is an element and the name has just started
                Buffer[index] = {Data[i]}
                State[index] = stateOPENINGELEMENT
            end if
        elsif State[index] = stateBANGTAG then
            Buffer[index] &= Data[i]
            if equal(Buffer[index],"--") then
                Buffer[index] = ""
                State[index] = stateCOMMENT
            elsif equal(Buffer[index],"[CDATA[") then
                Buffer[index] = ""
                State[index] = stateCDATA
            elsif find(Data[i],WHITESPACE) then
                if equal(Buffer[index][1..length(Buffer[index])-1],"DOCTYPE") then
                    Buffer[index] = ""
                    State[index] = stateDOCTYPE
                else
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_OUTSIDE_DTD)
                    return 0
                end if
            end if
        elsif State[index] = stateCOMMENT then
            Buffer[index] &= Data[i]
            -- Check for end of comment tag
            if length(Buffer[index]) >= 3 and
               equal(Buffer[index][length(Buffer[index])-2..length(Buffer[index])],"-->") then
                State[index] = stateCHARS
                RaiseCommentEvent(hInst[index],Buffer[index][1..length(Buffer[index])-3])
                Buffer[index] = ""
            end if
        elsif State[index] = stateCDATA then
            Buffer[index] &= Data[i]
            -- Check for end of CDATA tag
            if length(Buffer[index]) >= 3 and
               equal(Buffer[index][length(Buffer[index])-3..length(Buffer[index])],"]]>") then
                State[index] = stateCHARS
                eebax_Characters(hInst[index],Buffer[index][1..length(Buffer[index])-3])
                Buffer[index] = ""
            end if
        elsif State[index] = stateDOCTYPE then
            -- The Buffer[index] = "" lines here are places to pick up DTD name if needed
            if Data[i] = '>' then
                Buffer[index] = ""
                State[index] = stateCHARS
            elsif Data[i] = '[' then
                Buffer[index] = ""
                Section[index] = sectionINTERNALDTD
                State[index] = stateDTD
            elsif find(Data[i],WHITESPACE) then
                Buffer[index] = rtrim(Buffer[index])
                if length(Buffer[index]) > 0 then
                    Buffer[index] = ""
                    State[index] = stateDTDREF
                end if
            else
                Buffer[index] &= Data[i]
            end if
        elsif State[index] = stateDTDREF then
            if Data[i] = '[' or Data[i] = '>' then
                -- An external ID for a DTD has been read in, process it
                Buffer[index] = trim(Buffer[index])
                for n = 1 to length(Buffer[index]) do
                    if find(Buffer[index][n],WHITESPACE) then
                        if equal(Buffer[index][1..n-1],"SYSTEM") then
                            Buffer[index] = trim(Buffer[index][n..length(Buffer[index])])
                            -- So that below we can find out what kind of identifier it was
                            temp = 'S'
                        elsif equal(Buffer[index][n],"PUBLIC") then
                            -- Cut out the PubidLiteral, I don't recon it's even worth bothering with
                            Buffer[index] = trim(Buffer[index][n..length(Buffer[index])])
                            if length(Buffer[index]) > 3 and find(Buffer[index][1],"\"\'") then
                                -- The following line take only the buffer starting at the second ocurence of the first character in the buffer
                                -- In other words it will cut out the first string literal
                                Buffer[index] = trim(Buffer[index][find(Buffer[index][1],Buffer[index][2..length(Buffer[index])])+2..length(Buffer[index])])
                            end if
                            -- So that below we can find out what kind of identifier it was
                            temp = 'P'
                        else
                            -- All external IDs must be either SYSTEM or PUBLIC
                            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_EXTERNAL_ID)
                            return 0
                        end if
                        
                        if length(Buffer[index]) < 2 or
                           not find(Buffer[index][1],"\"\'") then
                            --If it starts with a quote then it will end with a quote otherwise string processing would have choked
                            RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_EXPECTED_STRING_LITERAL)
                            return 0
                        end if
                        Buffer[index] = Buffer[index][2..length(Buffer[index])-1]
                        -- Request that the calling application loads the DTD
                        Section[index] = sectionEXTERNALDTD
                        State[index] = stateDTD
                        temp = {temp,Buffer[index]}
                        Buffer[index] = ""
                        RaiseLoadExternalEvent(hInst[index],temp[1] = 'P',temp[2])
                        if State[index] = stateERROR then
                            -- Error ocured in DTD proccessing
                            return 0
                        end if
                        exit
                    end if
                end for
                Section[index] = sectionMAIN
                if Data[i] = '>' then
                    State[index] = stateCHARS
                else
                    Buffer[index] = ""
                    Section[index] = sectionINTERNALDTD
                    State[index] = stateDTD
                end if
            else
                if find(Data[i],"\"\'") then
                    -- A string is starting
                    WithinString[index] = Data[i]
                end if
                Buffer[index] &= Data[i]
            end if
        elsif State[index] = statePROCESSINGINSTRUCTION then
            Buffer[index] &= Data[i]
            if length(Buffer[index]) >= 2 and 
               equal(Buffer[index][length(Buffer[index])-1..length(Buffer[index])],"?>") then
                 State[index] = stateCHARS
                 ParseProcessingInstruction(hInst[index],Buffer[index][1..length(Buffer[index])-2])
                 Buffer[index] = ""
            end if
        elsif State[index] = stateOPENINGELEMENT then
            if find(Data[i],WHITESPACE) then
                -- Normalize the whitespace (any block of whitespace should be reduced to one space
                -- The first char will never be whitespace (would have been trapped above) so it's ok to assume there is at least one char in the buffer already
                if Buffer[index][length(Buffer[index])] != ' ' then
                    Buffer[index] &= ' '
                end if
            elsif Data[i] = '>' then
                -- Make sure the tag had some contents
                if length(Buffer[index]) = 0 then
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_NAME_CHAR)
                    return 0
                end if
                State[index] = stateCHARS
                -- The tag has ended, parse it fully
                ParseOpeningElement(hInst[index],Buffer[index])
                Buffer[index] = ""
            else
                Buffer[index] &= Data[i]
                if find(Data[i],"\"\'") then
                    -- A string is starting
                    WithinString[index] = Data[i]
                end if
            end if
        elsif State[index] = stateCLOSEELEMENT then
            if Data[i] = '>' then
                Buffer[index] = rtrim(Buffer[index])
                if find(' ',Buffer[index]) then
                    RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_WHITESPACE)
                    return 0
                end if
                State[index] = stateCHARS
                eebax_EndElement(hInst[index],Buffer[index])
                Buffer[index] = ""
            elsif find(Data[i],WHITESPACE) then
                --Normalize the whitespace to a space
                Buffer[index] &= ' '
            else
                Buffer[index] &= Data[i]
            end if
        elsif State[index] = stateDTD then
            if Data[i] = '<' then
                State[index] = stateDTDTAG
                Buffer[index] = ""
            elsif Data[i] = ']' and Section[index] = sectionINTERNALDTD then
                Section[index] = sectionMAIN
                State[index] = stateDOCTYPE
                Buffer[index] = ""
            elsif not find(Data[i],WHITESPACE) then
                -- Error
                RaiseParseErrorEvent(hInst[index],EEBAX_ERROR_INVALID_IN_DTD)
                return 0
            end if
        elsif State[index] = stateDTDTAG then
            if Data[i] = '>' then
                State[index] = stateDTD
                ParseDTDTag(hInst[index],Buffer[index])
                Buffer[index] = ""
            else
                Buffer[index] &= Data[i]
                if find(Data[i],"\"\'") then
                    -- A string is starting
                    WithinString[index] = Data[i]
                end if
            end if
        end if
    end for
    return 1
end function

-- END Parse routines